import{fileURLToPath}from"url";import{extname,join}from"path";import{readFileSync,existsSync}from"fs";const flagSymbol=Symbol("arg flag");function arg(e,{argv:t=process.argv.slice(2),permissive:o=!1,stopAtPositional:n=!1}={}){if(!e)throw new Error("Argument specification object is required");const r={_:[]},a={},s={};for(const t of Object.keys(e)){if(!t)throw new TypeError("Argument key cannot be an empty string");if("-"!==t[0])throw new TypeError(`Argument key must start with '-' but found: '${t}'`);if(1===t.length)throw new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${t}`);if("string"==typeof e[t]){a[t]=e[t];continue}let o=e[t],n=!1;if(Array.isArray(o)&&1===o.length&&"function"==typeof o[0]){const[e]=o;o=(t,o,n=[])=>(n.push(e(t,o,n[n.length-1])),n),n=e===Boolean||!0===e[flagSymbol]}else{if("function"!=typeof o)throw new TypeError(`Type missing or not a function or valid array type: ${t}`);n=o===Boolean||!0===o[flagSymbol]}if("-"!==t[1]&&t.length>2)throw new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${t}`);s[t]=[o,n]}for(let e=0,i=t.length;e<i;e++){const i=t[e];if(n&&r._.length>0){r._=r._.concat(t.slice(e));break}if("--"===i){r._=r._.concat(t.slice(e+1));break}if(i.length>1&&"-"===i[0]){const n="-"===i[1]||2===i.length?[i]:i.slice(1).split("").map((e=>`-${e}`));for(let i=0;i<n.length;i++){const l=n[i],[c,p]="-"===l[1]?l.split(/=(.*)/,2):[l,void 0];let m=c;for(;m in a;)m=a[m];if(!(m in s)){if(o){r._.push(l);continue}{const e=new Error(`Unknown or unexpected option: ${c}`);throw e.code="ARG_UNKNOWN_OPTION",e}}const[u,g]=s[m];if(!g&&i+1<n.length)throw new TypeError(`Option requires argument (but was followed by another short argument): ${c}`);if(g)r[m]=u(!0,m,r[m]);else if(void 0===p){if(t.length<e+2||t[e+1].length>1&&"-"===t[e+1][0]&&(!t[e+1].match(/^-?\d*(\.(?=\d))?\d*$/)||u!==Number&&("undefined"==typeof BigInt||u!==BigInt))){throw new Error(`Option requires argument: ${c}${c===m?"":` (alias for ${m})`}`)}r[m]=u(t[e+1],m,r[m]),++e}else r[m]=u(p,m,r[m])}}else r._.push(i)}return r}async function getTracer(){return global.$_$tracer}arg.flag=e=>(e[flagSymbol]=!0,e),arg.COUNT=arg.flag(((e,t,o)=>(o||0)+1));import{getFormat,transformSource,resolve as resolveImplementation}from"./hooks.mjs";const extensionFormatMap={__proto__:null,".cjs":"commonjs",".js":"module",".mjs":"module",".json":"json"},legacyExtensionFormatMap={__proto__:null,".cjs":"commonjs",".js":"commonjs",".json":"commonjs",".mjs":"module",".node":"commonjs"};function getOptionValue(e){return parseOptions(),options[e]}let options;function parseOptions(){options||(options={"--preserve-symlinks":!1,"--preserve-symlinks-main":!1,"--input-type":void 0,"--experimental-specifier-resolution":"explicit","--experimental-policy":void 0,"--conditions":[],"--pending-deprecation":!1,...parseArgv(getNodeOptionsEnvArgv()),...parseArgv(process.execArgv),...getOptionValuesFromOtherEnvVars()})}function parseArgv(e){return arg({"--preserve-symlinks":Boolean,"--preserve-symlinks-main":Boolean,"--input-type":String,"--experimental-specifier-resolution":String,"--es-module-specifier-resolution":"--experimental-specifier-resolution","--experimental-policy":String,"--conditions":[String],"--pending-deprecation":Boolean,"--experimental-json-modules":Boolean,"--experimental-wasm-modules":Boolean},{argv:e,permissive:!0})}function getNodeOptionsEnvArgv(){const e=[];return ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS||"",e)}function ParseNodeOptionsEnvVar(e,t){const o=[];let n=!1,r=!0;for(let a=0;a<e.length;++a){let s=e[a];if("\\"===s&&n){if(a+1===e.length)return t.push("invalid value for NODE_OPTIONS (invalid escape)\n"),o;s=e[++a]}else{if(" "===s&&!n){r=!0;continue}if('"'===s){n=!n;continue}}r?(o.push(s),r=!1):o[o.length-1]+=s}return n&&t.push("invalid value for NODE_OPTIONS (unterminated string)\n"),o}function getOptionValuesFromOtherEnvVars(){const e={};return"1"===process.env.NODE_PENDING_DEPRECATION&&(e["--pending-deprecation"]=!0),e}const experimentalSpeciferResolution=getOptionValue("--experimental-specifier-resolution"),experimentalJsonModules=getOptionValue("--experimental-json-modules"),experimentalWasmModules=getOptionValue("--experimental-wasm-modules"),packageJSONCache=new Map;function getPackageConfig(e){const t=packageJSONCache.get(e);if(void 0!==t)return t;let o,n;try{o=readFileSync(e,"utf8")}catch(e){}if(void 0===o){const t={pjsonPath:e,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJSONCache.set(e,t),t}try{n=JSON.parse(o)}catch(e){throw new Error("Unexpected result: "+o+e.toString())}let{imports:r,main:a,name:s,type:i}=n;const{exports:l}=n;"object"==typeof r&&null!==r||(r=void 0),"string"!=typeof a&&(a=void 0),"string"!=typeof s&&(s=void 0),"module"!==i&&"commonjs"!==i&&(i="none");const c={pjsonPath:e,exists:!0,main:a,name:s,type:i,exports:l,imports:r};return packageJSONCache.set(e,c),c}function getPackageScopeConfig(e){let t=new URL("./package.json",e);for(;;){if(t.pathname.endsWith("node_modules/package.json"))break;const o=getPackageConfig(fileURLToPath(t),e);if(o.exists)return o;const n=t;if(t=new URL("../package.json",t),t.pathname===n.pathname)break}const o=fileURLToPath(t),n={pjsonPath:o,exists:!1,main:void 0,name:void 0,type:"none",exports:void 0,imports:void 0};return packageJSONCache.set(o,n),n}function defaultGetFormat(e,t,o){if(e.startsWith("node:"))return{format:"builtin"};const n=new URL(e);if("data:"===n.protocol){const[,e]=/^([^/]+\/[^;,]+)(?:[^,]*?)(;base64)?,/.exec(n.pathname)||[null,null,null];return{format:{__proto__:null,"text/javascript":"module","application/json":experimentalJsonModules?"json":null,"application/wasm":experimentalWasmModules?"wasm":null}[e]||null}}if("file:"===n.protocol){const t=extname(n.pathname);let o;if(o=".js"===t?"module"===getPackageScopeConfig(n.href).type?"module":"commonjs":extensionFormatMap[t],!o){if("node"!==experimentalSpeciferResolution)throw new Error(`Unknown Extension Type: ${t}, ${fileURLToPath(e)}`);process.emitWarning("The Node.js specifier resolution in ESM is experimental.","ExperimentalWarning"),o=legacyExtensionFormatMap[t]}return{format:o||null}}return{format:null}}export async function load(e,t,o){const n=pnp?async(e,t,n)=>pnp.load(e,t,o):o,r=(await getFormat(e,t,defaultGetFormat)).format;let a,s;if("builtin"!==r&&"commonjs"!==r){const t=await getTracer();if(t&&t._esm){const o=t._esm;if(e===o.scratchFileUrl)return{format:r,source:o.scratchFileContent,shortCircuit:!0}}const o=await n(e,{format:r},n),i=o.source;if(s=o.shortCircuit,null==i)throw new Error(`Failed to load raw source: Format was '${r}' and url was '${e}''.`);const l=(e,t,o)=>({source:e}),{source:c}=await transformSource(i,{url:e,format:r},l);a=c}else{const t=await n(e,{format:r},n);a=t.source,s=t.shortCircuit}return{format:r,source:a,shortCircuit:s}}let pnp;export async function resolve(e,t,o){if(void 0===pnp){pnp=null;const e=join(process.cwd(),".pnp.loader.mjs");try{existsSync(e)&&(pnp=await import(e))}catch(e){}}return resolveImplementation(e,t,pnp?(e,t,n)=>pnp.resolve(e,t,o):o)}export function globalPreload(e){if(parseInt(process.versions.node.split(".")[0],10)<20)return;if(!e||!e.port)throw new Error("Unexpected globalPreload argument value");const{port:t}=e;return t.onmessage=e=>{const{quokkaSettings:o,serverPath:n,scratchFileUrl:r,scratchFileContent:a,sessionId:s,localProjectDirUrl:i,settingsDirUrl:l,tempDirUrl:c}=e.data;global.$_$tracer=global.$_$tracer||{},global.$_$tracer._esm=global.$_$tracer._esm||{},global.$_$tracer._esm.quokkaSettings=o,global.$_$tracer._esm.serverPath=n,global.$_$tracer._esm.scratchFileUrl=r,global.$_$tracer._esm.scratchFileContent=a,global.$_$tracer._esm.localProjectDirUrl=i,global.$_$tracer._esm.settingsDirUrl=l,global.$_$tracer._esm.tempDirUrl=c,global.$_$tracer.sessionId=global.$_$session=s,global.$_$tracer._doWhenReceiverIsReady=function(e){return e()},global.$_$tracer._send=function(e,o){t.postMessage({method:"tracer._doWhenReceiverIsReady._send",args:[e,o]})}},"    global.$_$esmHooksPort = port;\n  "}